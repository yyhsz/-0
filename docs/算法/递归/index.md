# 递归

递归（Recursion）
基本上，所有的递归问题都可以用递推公式来表示。

## 三个条件

只要同时满足以下三个条件，就可以用递归来解决。

1. 一个问题的解可以分解为几个子问题的解何为子问题？子问题就是数据规模更小的问题。
2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样。
3. 存在递归终止条件把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。

## 递归代码怎么写

计算机擅长做重复的事情，所以递归正合它的胃口。而我们人脑更喜欢平铺直叙的思维方式。当我们看到递归时，我们总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。

因此，编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。递归代码要警惕堆栈溢出。

## 递归存在的问题

### 堆栈溢出

函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。

### 重复计算

为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。

## 递归转为非递归

来看一个经典爬楼梯问题

```js
//递归解法包含：传递（函数调用）与值回归两个步骤
//非递归解法则是从最初的时候慢慢加到n
function resolve(n) {
  if (n === 1) return 1;
  if (n === 2) return 2;
  let res = 0,
    pre = 2,
    prepre = 1;

  for (let i = 3; i <= n; i++) {
    let res = pre + prepre; //每一次结果都是上两次结果的和，相当于递推公式
    prepre = pre;
    pre = res;
  }
  return res;
}
```

那是不是所有的递归代码都可以改为这种迭代循环的非递归写法呢？笼统地讲，是的。因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。

如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。

## 746 爬楼梯的最小花费
