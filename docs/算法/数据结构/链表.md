# 链表

## 定义

链表并不需要一块连续的内存空间，它通过“指针”将一组零散的内存块串联起来使用。

链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的“结点”。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。

其中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作头结点，把最后一个结点叫作尾结点。其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址 NULL，表示这是链表上最后一个结点。

链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。

### 单链表

### 双向链表

双向链表比起单链表哪里有优势？

在已知某个节点的情况下，在该结点进行删除或插入双向链表都更有优势；因为单向链表在知道某个节点的情况下删除、插入需要找到前驱节点，这一过程复杂度 O(n)。

如果我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度。

### 如何基于链表实现 LRU 缓存淘汰算法

LRU：Least Recently Used 最近最少使用策略

### 关于“写链表”

#### 技巧一：理解指针或引用的含义

我们知道，有些语言有“指针”的概念，比如 C 语言；有些语言没有指针，取而代之的是“引用”，比如 Java、Python。不管是“指针”还是“引用”，实际上，它们的意思都是一样的，都是存储所指对象的内存地址。

#### 技巧二：警惕指针丢失和内存泄漏

#### 技巧三：利用哨兵简化实现难度

对于单链表的插入操作，第一个结点和其他结点的插入逻辑是不一样的。

针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。

这种利用哨兵简化编程难度的技巧，在很多代码实现中都有用到，比如插入排序、归并排序、动态规划等。

#### 技巧四：重点留意边界条件处理

我经常用来检查链表代码是否正确的边界条件有这样几个：

- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

#### 技巧五：举例画图，辅助思考

#### 推荐 leetcode 题目

这几个链表常见操作一定要熟记甚至手写：206，141，21，19，876
